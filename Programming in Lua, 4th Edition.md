
# Lua编程（第四版）
## Programming in Lua, 4th Edition

*作者：* Roberto Ierusalimschy

*Copyright © 2016, 2003 Roberto Ierusalimschy*

![LOGO](LOGO.png)



## **目录**
- [关于本书](#OO)<span id="~OO"></span>
- [第一篇 基础知识](#A)
  - [第1章 开始](#1)
    - [Chunks](#1.1)
    - [一些词法约定](#1.2)
    - [全局变量](#1.3)
    - [类型与值](#1.4)
        - [Nil](#1.4.1)
        - [布尔值](#1.4.2)
    - [独立解释器](#1.5)
  - [第2章 番外：八皇后问题](#2)
  - [第3章 数值(number)](#3)
    - [数词](#3.1)
    - [算术运算符](#3.2)
    - [关系运算符](#3.3)
    - [数学库](#3.4)
      - [随机数生成器](#3.4.1)
      - [舍入函数](#3.4.2)
    - [极值](#3.5)
    - [转换](#3.6)
    - [优先级](#3.7)
    - [之前版本的整型](#3.8)
  - [第4章 字符串(string)](#4)
    - [字符串字面值](#4.1)
    - [长字符串](#4.2)
    - [强制转换](#4.3)
    - [String库](#4.4)
    - [Unicode](#4.5)
  - [第5章 表(table)](#5)
    - [表索引](#5.1)
    - [表构造](#5.2)
    - [数组、列表与序列](#5.3)
    - [表遍历](#5.4)
    - [安全导航](#5.5)
    - [Table库](#5.6)
  - [第6章 函数(function)](#6)
    - [多返回值](#6.1)
    - [可变参函数](#6.2)
    - [函数 *table.unpack*](#6.3)
    - [正确的尾调用？](#6.4)
  - [第7章 外面的世界](#7)
    - [简易的I/O模型](#7.1)
    - [完备的I/O模型](#7.2)
    - [其他的文件操作](#7.3)
    - [其他系统调用](#7.4)
      - [运行系统命令](#7.4.1)
  - [第8章 其他补充](#8)
    - [局部变量与块(block)](#8.1)
    - [控制结构](#8.2)
      - [*if* *else* *then*](#8.2.1)
      - [*while*](#8.2.2)
      - [*repeat*](#8.2.3)
      - [数值 *for* 循环](#8.2.4)
      - [泛型 *for* 循环](#8.2.5)
    - [*break* 、 *return* 与 *goto*](#8.3)
- [第二篇 开始编程](#B)
  - [第9章 闭包](#9)
    - [函数-第一级值类型](#9.1)
    - [非全局函数](#9.2)
    - [词法作用域](#9.3)
    - [函数式编程的尝试](#9.4)
  - [第10章 模式匹配](#10)
    - [模式匹配函数](#10.1)
      - [函数 *string.find*](#10.1.1)
      - [函数 *string.match*](#10.1.2)
      - [函数 *string.gsub*](#10.1.3)
      - [函数 *string.gmatch*](#10.1.4)
    - [模式](#10.2)
    - [捕获](#10.3)
    - [替换](#10.4)
      - [URL编码](#10.4.1)
      - [制表符扩展](#10.4.2)
    - [转换的技巧](#10.5)
  - [第11章 番外：最高频词问题](#11)
  - [第12章 日期与时间](#12)
    - [函数 *os.time*](#12.1)
    - [函数 *os.date*](#12.2)
    - [日期-时间操作](#12.3)
  - [第13章 位与字节](#13)
    - [位运算](#13.1)
    - [无符号整型](#13.2)
    - [二进制数据的打包与解包](#13.3)
    - [二进制文件](#13.4)
  - [第14章 数据结构](#14)
    - [数组](#14.1)
    - [矩阵与多维数组](#14.2)
    - [链表](#14.3)
    - [队列与双端队列](#14.4)
    - [反向表](#14.5)
    - [集合与*bag*(可重复集合)](#14.6)
    - [字符串缓冲区](#14.7)
    - [图表](#14.8)
  - [第15章 数据文件和序列化](#15)
    - [数据文件](#15.1)
    - [序列化](#15.2)
      - [保存无循环引用的表](#15.2.1)
      - [保存带循环引用表](#15.2.2)
  - [第16章 编译、执行与错误](#16)
    - [编译](#16.1)
    - [预编译代码](#16.2)
    - [错误](#16.3)
    - [错误处理与异常](#16.4)
    - [错误信息与追踪](#16.5)
  - [第17章 模块与包](#17)
    - [函数*require*](#17.1)
      - [重命名模块](#17.1.1)
      - [路径搜索](#17.1.2)
      - [搜索器](#17.1.3)
    - [Lua中编写模块的基本方式](#17.2)
    - [子模块与包](#17.3)
- [第三篇 Lua-isms(主义)](#C)
  - [第18章 迭代器与泛型*for*循环](#18)
    - [迭代器与闭包](#18.1)
    - [泛型*for*循环的语义](#18.2)
    - [无状态迭代器](#18.3)
    - [按顺序遍历表](#18.4)
    - [真正的迭代器](#18.5)
  - [第19章 番外：马尔科夫链算法](#19)
  - [第20章 元表与元方法](#20)
    - [算术元方法](#20.1)
    - [关系元方法](#20.2)
    - [库内定义的元方法](#20.3)
    - [访问表的元方法](#20.4)
      - [元方法 *__index*](#20.4.1)
      - [元方法 *__newindex*](#20.4.2)
      - [表的默认值](#20.4.3)
      - [追踪表访问](#20.4.4)
      - [只读表](#20.4.5)
  - [第21章 面向对象编程](#21)
    - [类](#21.1)
    - [继承](#21.2)
    - [多继承](#21.3)
    - [私有](#21.4)
    - [单一方法](#21.5)
    - [双重表示](#21.6)
  - [第22章 环境](#22)
    - [动态名字的全局变量](#22.1)
    - [全局变量声明](#22.2)
    - [非全局环境](#22.3)
    - [使用 *_ENV*](#22.4)
    - [环境与模块](#22.5)
    - [*_ENV*与*load*](#22.6)
  - [第23章 垃圾](#23)
    - [弱表](#23.1)
    - [记忆函数](#23.2)
    - [对象属性](#23.3)
    - [再谈表的默认值](#23.4)
    - [Ephemeron表](#23.5)
    - [析构器(析构函数...)](#23.6)
    - [垃圾回收器](#23.7)
    - [控制回收速度(节奏)](#23.8)
  - [第24章 协程](#24)
    - [协程基础](#24.1)
    - [谁是Boss？](#24.2)
    - [用作迭代器的协程](#24.3)
    - [事件驱动编程](#24.4)
  - [第25章 反射](#25)
    - [内省机制(设施)](#25.1)
      - [访问局部变量](#25.1.1)
      - [访问非局部变量](#25.1.2)
      - [访问其他协程](#25.1.3)
    - [钩子](#25.2)
    - [剖析/监控](#25.3)
    - [沙盒](#25.4)
  - [第26章 基于协程的多线程](#26)
- [第四篇 C API](#D)
  - [第27章 C API的概述](#27)
    - [第一个例子](#27.1)
    - [栈](#27.2)
      - [推入元素](#27.2.1)
      - [查询元素](#27.2.2)
      - [其他栈操作](#27.2.3)
    - [C API的错误处理](#27.3)
      - [应用代码的错误处理](#27.3.1)
      - [库代码的错误处理](#27.3.2)
    - [内存分配](#27.4)
  - [第28章 扩张你的应用](#28)
    - [基础](#28.1)
    - [表操作](#28.2)
      - [一些捷径](#28.2.1)
    - [调用Lua函数](#28.3)
    - [通用调用函数](#28.4)
  - [第29章 Lua调用C](#29)
    - [C函数](#29.1)
    - [延续函数](#29.2)
    - [C模块](#29.3)
  - [第30章 编写C函数的技巧](#30)
    - [数组操作](#30.1)
    - [字符串操作](#30.2)
    - [在C函数中存储状态](#30.3)
      - [注册表](#30.3.1)
      - [上值?(Upvalues)](#30.3.2)
      - [共享上值?(Shared Upvalues)](#30.3.3)
  - [第31章 C中的用户定义类型](#31)
    - [用户数据(Userdata)](#31.1)
    - [元表](#31.2)
    - [面向对象访问](#31.3)
    - [数组访问](#31.4)
    - [轻量用户数据(Light Userdata)](#31.5)
  - [第32章 管理资源](#32)
    - [目录迭代](#32.1)
    - [XML解析器](#32.2)
  - [第33章 线程与状态](#33)
    - [多线程](#33.1)
    - [Lua状态](#33.2)


## 关于本书[▲](#~OO)<span id="OO"></span>

&emsp;&emsp;1993年，Waldemar、Luiz和我开始开发Lua的时候，我们根本没想到它如此普及。得益于Lua简单、可扩展、可移植、高效的特点，这个开始仅作为两个特定项目的内部使用的脚本语言，如今被广泛用于所有领域，诸如嵌入式系统、移动设备、IoT等领域，当然还有游戏领域。

&emsp;&emsp;我们设计Lua最初是为了将其整合到用C/C++以及其他传统语言编写的软件中。这种整合带来了很多好处。Lua是一个小而简易的语言，一部分原因是它不尝试去做C已经很擅长的事情，比如纯粹的性能表现和与第三方软件的接口，而是依赖C完成这些任务。Lua做的是C不擅长的：适当远离硬件、动态结构、无冗余、易于测试与调试等。为达到这些目的，Lua拥有了一个安全的环境、自动内存管理以及处理字符串和其他动态大小的数据结构的方式。

&emsp;&emsp;Lua部分能力源自它的库，这不是偶然。毕竟，Lua其中一个优势就是他的可扩张性。其很多特性促成了这一优势。动态类型允许很大程度的多态性。自动内存管理简化了接口，因为没必要去决定谁负责分配与回收内存以及怎样处理处理工作流。一阶函数类型允许高度的参数化，使得函数功能更加多样。

&emsp;&emsp;Lua不仅仅是一门可扩张语言，也是一门胶水语言。Lua支持基于组件的软件开发方式，我们可以将已存在的高阶组件粘贴在一起生成一个应用。这些组件由诸如C/C++这种编译型静态类型语言编写而成，然后我们用Lua将其组合和连结起来。通常，这些组件（或对象）代表着更加具体、更加低级并且在开发过程中不会有很多变化的概念（比如部件和数据结构），并占用着最终程序的大部分CPU时间。

